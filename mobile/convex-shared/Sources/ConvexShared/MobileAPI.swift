// Auto-generated by lazyconvex-codegen-swift. DO NOT EDIT.
// swiftlint:disable file_length
import Foundation

extension BlogProfileAPI {
    public static func upsert(
        avatar: String? = nil,
        bio: String? = nil,
        displayName: String? = nil,
        notifications: Bool? = nil,
        theme: BlogProfileTheme? = nil
    ) async throws {
        var args = [String: Any]()
        if let avatar {
            args["avatar"] = avatar
        }
        if let bio {
            args["bio"] = bio
        }
        if let displayName {
            args["displayName"] = displayName
        }
        if let notifications {
            args["notifications"] = notifications
        }
        if let theme {
            args["theme"] = theme.rawValue
        }
        try await ConvexService.shared.mutate("blogProfile:upsert", args: args)
    }
}

extension BlogProfileAPI {
    @preconcurrency
    public static func subscribeGet(
        onUpdate: @escaping @Sendable @MainActor (BlogProfile) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () },
        onNull: @escaping @Sendable @MainActor () -> Void = { () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: get, args: [:], type: BlogProfile.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeBlogProfile(
            to: get,
            args: [:],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) },
            onNull: { onNull() }
        )
        #endif
    }
}

extension ProjectAPI {
    public static func create(
        orgId: String,
        description: String? = nil,
        editors: [String]? = nil,
        name: String,
        status: ProjectStatus? = nil
    ) async throws {
        var args: [String: Any] = ["orgId": orgId, "name": name]
        if let description {
            args["description"] = description
        }
        if let editors {
            args["editors"] = editors
        }
        if let status {
            args["status"] = status.rawValue
        }
        try await ConvexService.shared.mutate("project:create", args: args)
    }

    public static func update(
        orgId: String,
        id: String,
        description: String? = nil,
        editors: [String]? = nil,
        name: String? = nil,
        status: ProjectStatus? = nil,
        expectedUpdatedAt: Double? = nil
    ) async throws {
        var args: [String: Any] = ["id": id, "orgId": orgId]
        if let description {
            args["description"] = description
        }
        if let editors {
            args["editors"] = editors
        }
        if let name {
            args["name"] = name
        }
        if let status {
            args["status"] = status.rawValue
        }
        if let expectedUpdatedAt {
            args["expectedUpdatedAt"] = expectedUpdatedAt
        }
        try await ConvexService.shared.mutate("project:update", args: args)
    }

    public static func rm(orgId: String, id: String) async throws {
        try await ConvexService.shared.mutate("project:rm", args: ["id": id, "orgId": orgId])
    }

    public static func bulkRm(orgId: String, ids: [String]) async throws {
        try await ConvexService.shared.mutate("project:bulkRm", args: ["ids": ids, "orgId": orgId])
    }

    public static func addEditor(orgId: String, editorId: String, projectId: String) async throws {
        try await ConvexService.shared.mutate("project:addEditor", args: ["editorId": editorId, "orgId": orgId, "projectId": projectId])
    }

    public static func removeEditor(orgId: String, editorId: String, projectId: String) async throws {
        try await ConvexService.shared.mutate("project:removeEditor", args: ["editorId": editorId, "orgId": orgId, "projectId": projectId])
    }
}

extension ProjectAPI {
    @preconcurrency
    public static func subscribeList(
        orgId: String,
        where filterWhere: ProjectWhere?,
        onUpdate: @escaping @Sendable @MainActor (PaginatedResult<Project>) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        let args = listArgs(orgId: orgId, where: filterWhere)
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: list,
            args: args,
            type: PaginatedResult<Project>.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribePaginatedProjects(
            to: list,
            args: args,
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeRead(
        orgId: String,
        id: String,
        onUpdate: @escaping @Sendable @MainActor (Project) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: read,
            args: ["id": id, "orgId": orgId],
            type: Project.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeProject(
            to: read,
            args: ["id": id, "orgId": orgId],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeEditors(
        orgId: String,
        projectId: String,
        onUpdate: @escaping @Sendable @MainActor ([EditorEntry]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: editors,
            args: ["orgId": orgId, "projectId": projectId],
            type: [EditorEntry].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeEditors(
            to: editors,
            args: ["orgId": orgId, "projectId": projectId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }
}

extension WikiAPI {
    public static func create(
        orgId: String,
        content: String? = nil,
        deletedAt: Double? = nil,
        editors: [String]? = nil,
        slug: String,
        status: WikiStatus,
        title: String
    ) async throws {
        var args: [String: Any] = ["orgId": orgId, "slug": slug, "status": status.rawValue, "title": title]
        if let content {
            args["content"] = content
        }
        if let deletedAt {
            args["deletedAt"] = deletedAt
        }
        if let editors {
            args["editors"] = editors
        }
        try await ConvexService.shared.mutate("wiki:create", args: args)
    }

    public static func update(
        orgId: String,
        id: String,
        content: String? = nil,
        deletedAt: Double? = nil,
        editors: [String]? = nil,
        slug: String? = nil,
        status: WikiStatus? = nil,
        title: String? = nil,
        expectedUpdatedAt: Double? = nil
    ) async throws {
        var args: [String: Any] = ["id": id, "orgId": orgId]
        if let content {
            args["content"] = content
        }
        if let deletedAt {
            args["deletedAt"] = deletedAt
        }
        if let editors {
            args["editors"] = editors
        }
        if let slug {
            args["slug"] = slug
        }
        if let status {
            args["status"] = status.rawValue
        }
        if let title {
            args["title"] = title
        }
        if let expectedUpdatedAt {
            args["expectedUpdatedAt"] = expectedUpdatedAt
        }
        try await ConvexService.shared.mutate("wiki:update", args: args)
    }

    public static func rm(orgId: String, id: String) async throws {
        try await ConvexService.shared.mutate("wiki:rm", args: ["id": id, "orgId": orgId])
    }

    public static func restore(orgId: String, id: String) async throws {
        try await ConvexService.shared.mutate("wiki:restore", args: ["id": id, "orgId": orgId])
    }

    public static func bulkRm(orgId: String, ids: [String]) async throws {
        try await ConvexService.shared.mutate("wiki:bulkRm", args: ["ids": ids, "orgId": orgId])
    }

    public static func addEditor(orgId: String, editorId: String, wikiId: String) async throws {
        try await ConvexService.shared.mutate("wiki:addEditor", args: ["editorId": editorId, "orgId": orgId, "wikiId": wikiId])
    }

    public static func removeEditor(orgId: String, editorId: String, wikiId: String) async throws {
        try await ConvexService.shared.mutate("wiki:removeEditor", args: ["editorId": editorId, "orgId": orgId, "wikiId": wikiId])
    }
}

extension WikiAPI {
    @preconcurrency
    public static func subscribeList(
        orgId: String,
        where filterWhere: WikiWhere?,
        onUpdate: @escaping @Sendable @MainActor (PaginatedResult<Wiki>) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        let args = listArgs(orgId: orgId, where: filterWhere)
        #if !SKIP
        return ConvexService.shared.subscribe(to: list, args: args, type: PaginatedResult<Wiki>.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribePaginatedWikis(
            to: list,
            args: args,
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeRead(
        orgId: String,
        id: String,
        onUpdate: @escaping @Sendable @MainActor (Wiki) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: read,
            args: ["id": id, "orgId": orgId],
            type: Wiki.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeWiki(
            to: read,
            args: ["id": id, "orgId": orgId],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeEditors(
        orgId: String,
        wikiId: String,
        onUpdate: @escaping @Sendable @MainActor ([EditorEntry]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: editors,
            args: ["orgId": orgId, "wikiId": wikiId],
            type: [EditorEntry].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeEditors(
            to: editors,
            args: ["orgId": orgId, "wikiId": wikiId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }
}

extension MobileAiAPI {
    public static func chat(chatId: String) async throws {
        #if !SKIP
        let _: [String: String] = try await ConvexService.shared.action(
            "mobileAi:chat",
            args: ["chatId": chatId],
            returning: [String: String].self
        )
        #else
        try await ConvexService.shared.action(name: "mobileAi:chat", args: ["chatId": chatId])
        #endif
    }
}

extension BlogAPI {
    public static func create(
        attachments: [String]? = nil,
        category: BlogCategory,
        content: String,
        coverImage: String? = nil,
        published: Bool,
        tags: [String]? = nil,
        title: String
    ) async throws {
        var args: [String: Any] = ["category": category.rawValue, "content": content, "published": published, "title": title]
        if let attachments {
            args["attachments"] = attachments
        }
        if let coverImage {
            args["coverImage"] = coverImage
        }
        if let tags {
            args["tags"] = tags
        }
        try await ConvexService.shared.mutate("blog:create", args: args)
    }

    public static func update(
        id: String,
        attachments: [String]? = nil,
        category: BlogCategory? = nil,
        content: String? = nil,
        coverImage: String? = nil,
        published: Bool? = nil,
        tags: [String]? = nil,
        title: String? = nil,
        expectedUpdatedAt: Double? = nil
    ) async throws {
        var args: [String: Any] = ["id": id]
        if let attachments {
            args["attachments"] = attachments
        }
        if let category {
            args["category"] = category.rawValue
        }
        if let content {
            args["content"] = content
        }
        if let coverImage {
            args["coverImage"] = coverImage
        }
        if let published {
            args["published"] = published
        }
        if let tags {
            args["tags"] = tags
        }
        if let title {
            args["title"] = title
        }
        if let expectedUpdatedAt {
            args["expectedUpdatedAt"] = expectedUpdatedAt
        }
        try await ConvexService.shared.mutate("blog:update", args: args)
    }

    public static func rm(id: String) async throws {
        try await ConvexService.shared.mutate("blog:rm", args: ["id": id])
    }

    public static func bulkRm(ids: [String]) async throws {
        try await ConvexService.shared.mutate("blog:bulkRm", args: ["ids": ids])
    }
}

extension BlogAPI {
    @preconcurrency
    public static func subscribeList(
        where filterWhere: BlogWhere?,
        onUpdate: @escaping @Sendable @MainActor (PaginatedResult<Blog>) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        let args = listArgs(where: filterWhere)
        #if !SKIP
        return ConvexService.shared.subscribe(to: list, args: args, type: PaginatedResult<Blog>.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribePaginatedBlogs(
            to: list,
            args: args,
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeRead(
        id: String,
        onUpdate: @escaping @Sendable @MainActor (Blog) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: read, args: ["id": id], type: Blog.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeBlog(to: read, args: ["id": id], onUpdate: { r in onUpdate(r) }, onError: { e in onError(e) })
        #endif
    }
}

extension MovieAPI {
    public static func load(tmdbId: Double) async throws -> Movie {
        #if !SKIP
        return try await ConvexService.shared.action("movie:load", args: ["tmdb_id": tmdbId], returning: Movie.self)
        #else
        return try await ConvexService.shared.actionMovie(name: "movie:load", args: ["tmdb_id": tmdbId])
        #endif
    }

    public static func search(query: String) async throws -> [Movie] {
        #if !SKIP
        return try await ConvexService.shared.action("movie:search", args: ["query": query], returning: [Movie].self)
        #else
        return try await Array(ConvexService.shared.actionMovies(name: "movie:search", args: ["query": query]))
        #endif
    }
}

extension FileAPI {
    public static func upload() async throws -> String {
        #if !SKIP
        try await ConvexService.shared.mutation("file:upload", args: [:])
        #else
        try await ConvexService.shared.mutateReturningString(name: "file:upload", args: [:])
        #endif
    }
}

extension ChatAPI {
    public static func create(
        isPublic: Bool,
        title: String
    ) async throws {
        let args: [String: Any] = ["isPublic": isPublic, "title": title]
        try await ConvexService.shared.mutate("chat:create", args: args)
    }

    public static func update(
        id: String,
        isPublic: Bool? = nil,
        title: String? = nil,
        expectedUpdatedAt: Double? = nil
    ) async throws {
        var args: [String: Any] = ["id": id]
        if let isPublic {
            args["isPublic"] = isPublic
        }
        if let title {
            args["title"] = title
        }
        if let expectedUpdatedAt {
            args["expectedUpdatedAt"] = expectedUpdatedAt
        }
        try await ConvexService.shared.mutate("chat:update", args: args)
    }

    public static func rm(id: String) async throws {
        try await ConvexService.shared.mutate("chat:rm", args: ["id": id])
    }

    public static func pubRead(id: String) async throws -> Chat {
        #if !SKIP
        try await ConvexService.shared.query("chat:pubRead", args: ["id": id])
        #else
        try await ConvexService.shared.queryChat(name: "chat:pubRead", args: ["id": id])
        #endif
    }
}

extension ChatAPI {
    @preconcurrency
    public static func subscribeList(
        where filterWhere: ChatWhere?,
        onUpdate: @escaping @Sendable @MainActor (PaginatedResult<Chat>) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        let args = listArgs(where: filterWhere)
        #if !SKIP
        return ConvexService.shared.subscribe(to: list, args: args, type: PaginatedResult<Chat>.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribePaginatedChats(
            to: list,
            args: args,
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeRead(
        id: String,
        onUpdate: @escaping @Sendable @MainActor (Chat) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: read, args: ["id": id], type: Chat.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeChat(to: read, args: ["id": id], onUpdate: { r in onUpdate(r) }, onError: { e in onError(e) })
        #endif
    }

    @preconcurrency
    public static func subscribePubRead(
        id: String,
        onUpdate: @escaping @Sendable @MainActor (Chat) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: pubRead, args: ["id": id], type: Chat.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeChat(
            to: pubRead,
            args: ["id": id],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }
}

extension MessageAPI {
    public static func create(chatId: String, parts: [MessagePart], role: MessageRole) async throws {
        var partDicts = [[String: Any]]()
        for p in parts {
            var d: [String: Any] = ["type": p.type.rawValue]
            if let text = p.text {
                d["text"] = text
            }
            if let image = p.image {
                d["image"] = image
            }
            if let file = p.file {
                d["file"] = file
            }
            if let name = p.name {
                d["name"] = name
            }
            partDicts.append(d)
        }
        try await ConvexService.shared.mutate("message:create", args: ["chatId": chatId, "role": role.rawValue, "parts": partDicts])
    }

    public static func list(chatId: String) async throws -> [Message] {
        #if !SKIP
        try await ConvexService.shared.query("message:list", args: ["chatId": chatId])
        #else
        try await Array(ConvexService.shared.queryMessages(name: "message:list", args: ["chatId": chatId]))
        #endif
    }

    public static func pubGet(id: String) async throws -> Message {
        #if !SKIP
        try await ConvexService.shared.query("message:pubGet", args: ["id": id])
        #else
        try await ConvexService.shared.queryMessage(name: "message:pubGet", args: ["id": id])
        #endif
    }

    public static func pubList(chatId: String) async throws -> [Message] {
        #if !SKIP
        try await ConvexService.shared.query("message:pubList", args: ["chatId": chatId])
        #else
        try await Array(ConvexService.shared.queryMessages(name: "message:pubList", args: ["chatId": chatId]))
        #endif
    }
}

extension MessageAPI {
    @preconcurrency
    public static func subscribeList(
        chatId: String,
        onUpdate: @escaping @Sendable @MainActor ([Message]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: list,
            args: ["chatId": chatId],
            type: [Message].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeMessages(
            to: list,
            args: ["chatId": chatId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribePubList(
        chatId: String,
        onUpdate: @escaping @Sendable @MainActor ([Message]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: pubList,
            args: ["chatId": chatId],
            type: [Message].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeMessages(
            to: pubList,
            args: ["chatId": chatId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribePubGet(
        id: String,
        onUpdate: @escaping @Sendable @MainActor (Message) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: pubGet, args: ["id": id], type: Message.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeMessage(
            to: pubGet,
            args: ["id": id],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }
}

extension OrgProfileAPI {
    public static func upsert(
        avatar: String? = nil,
        bio: String? = nil,
        displayName: String? = nil,
        notifications: Bool? = nil,
        theme: OrgProfileTheme? = nil
    ) async throws {
        var args = [String: Any]()
        if let avatar {
            args["avatar"] = avatar
        }
        if let bio {
            args["bio"] = bio
        }
        if let displayName {
            args["displayName"] = displayName
        }
        if let notifications {
            args["notifications"] = notifications
        }
        if let theme {
            args["theme"] = theme.rawValue
        }
        try await ConvexService.shared.mutate("orgProfile:upsert", args: args)
    }
}

extension OrgProfileAPI {
    @preconcurrency
    public static func subscribeGet(
        onUpdate: @escaping @Sendable @MainActor (OrgProfile) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () },
        onNull: @escaping @Sendable @MainActor () -> Void = { () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: get, args: [:], type: OrgProfile.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeOrgProfile(
            to: get,
            args: [:],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) },
            onNull: { onNull() }
        )
        #endif
    }
}

extension OrgAPI {
    public static func acceptInvite(token: String) async throws {
        try await ConvexService.shared.mutation("org:acceptInvite", args: ["token": token])
    }

    public static func approveJoinRequest(requestId: String, isAdmin: Bool? = nil) async throws {
        var args: [String: Any] = ["requestId": requestId]
        if let isAdmin {
            args["isAdmin"] = isAdmin
        }
        try await ConvexService.shared.mutate("org:approveJoinRequest", args: args)
    }

    public static func cancelJoinRequest(requestId: String) async throws {
        try await ConvexService.shared.mutation("org:cancelJoinRequest", args: ["requestId": requestId])
    }

    public static func create(name: String, slug: String, avatarId: String? = nil) async throws {
        var data: [String: Any] = ["name": name, "slug": slug]
        if let avatarId {
            data["avatarId"] = avatarId
        }
        try await ConvexService.shared.mutate("org:create", args: ["data": data])
    }

    public static func get(orgId: String) async throws -> Org {
        #if !SKIP
        try await ConvexService.shared.query("org:get", args: ["orgId": orgId])
        #else
        try await ConvexService.shared.queryOrg(name: "org:get", args: ["orgId": orgId])
        #endif
    }

    public static func getBySlug(slug: String) async throws -> Org? {
        #if !SKIP
        try await ConvexService.shared.query("org:getBySlug", args: ["slug": slug])
        #else
        try await ConvexService.shared.queryNullableOrg(name: "org:getBySlug", args: ["slug": slug])
        #endif
    }

    public static func getOrCreate() async throws {
        try await ConvexService.shared.mutate("org:getOrCreate", args: [:])
    }

    public static func getPublic(slug: String) async throws -> Org? {
        #if !SKIP
        try await ConvexService.shared.query("org:getPublic", args: ["slug": slug])
        #else
        try await ConvexService.shared.queryNullableOrg(name: "org:getPublic", args: ["slug": slug])
        #endif
    }

    public static func invite(email: String, isAdmin: Bool, orgId: String) async throws {
        try await ConvexService.shared.mutation("org:invite", args: ["email": email, "isAdmin": isAdmin, "orgId": orgId])
    }

    public static func isSlugAvailable(slug: String) async throws -> SlugAvailability {
        #if !SKIP
        try await ConvexService.shared.query("org:isSlugAvailable", args: ["slug": slug])
        #else
        try await ConvexService.shared.querySlugAvailability(name: "org:isSlugAvailable", args: ["slug": slug])
        #endif
    }

    public static func leave(orgId: String) async throws {
        try await ConvexService.shared.mutation("org:leave", args: ["orgId": orgId])
    }

    public static func members(orgId: String) async throws -> [OrgMemberEntry] {
        #if !SKIP
        try await ConvexService.shared.query("org:members", args: ["orgId": orgId])
        #else
        try await Array(ConvexService.shared.queryOrgMemberEntrys(name: "org:members", args: ["orgId": orgId]))
        #endif
    }

    public static func membership(orgId: String) async throws -> OrgMembership {
        #if !SKIP
        try await ConvexService.shared.query("org:membership", args: ["orgId": orgId])
        #else
        try await ConvexService.shared.queryOrgMembership(name: "org:membership", args: ["orgId": orgId])
        #endif
    }

    public static func myJoinRequest(orgId: String) async throws -> OrgJoinRequest? {
        #if !SKIP
        try await ConvexService.shared.query("org:myJoinRequest", args: ["orgId": orgId])
        #else
        try await ConvexService.shared.queryNullableOrgJoinRequest(name: "org:myJoinRequest", args: ["orgId": orgId])
        #endif
    }

    public static func myOrgs() async throws -> [OrgWithRole] {
        #if !SKIP
        try await ConvexService.shared.query("org:myOrgs", args: [:])
        #else
        try await Array(ConvexService.shared.queryOrgWithRoles(name: "org:myOrgs", args: [:]))
        #endif
    }

    public static func pendingInvites(orgId: String) async throws -> [OrgInvite] {
        #if !SKIP
        try await ConvexService.shared.query("org:pendingInvites", args: ["orgId": orgId])
        #else
        try await Array(ConvexService.shared.queryOrgInvites(name: "org:pendingInvites", args: ["orgId": orgId]))
        #endif
    }

    public static func pendingJoinRequests(orgId: String) async throws -> [JoinRequestEntry] {
        #if !SKIP
        try await ConvexService.shared.query("org:pendingJoinRequests", args: ["orgId": orgId])
        #else
        try await Array(ConvexService.shared.queryJoinRequestEntrys(name: "org:pendingJoinRequests", args: ["orgId": orgId]))
        #endif
    }

    public static func rejectJoinRequest(requestId: String) async throws {
        try await ConvexService.shared.mutation("org:rejectJoinRequest", args: ["requestId": requestId])
    }

    public static func remove(orgId: String) async throws {
        try await ConvexService.shared.mutation("org:remove", args: ["orgId": orgId])
    }

    public static func removeMember(memberId: String) async throws {
        try await ConvexService.shared.mutation("org:removeMember", args: ["memberId": memberId])
    }

    public static func requestJoin(orgId: String, message: String? = nil) async throws {
        var args: [String: Any] = ["orgId": orgId]
        if let message {
            args["message"] = message
        }
        try await ConvexService.shared.mutate("org:requestJoin", args: args)
    }

    public static func revokeInvite(inviteId: String) async throws {
        try await ConvexService.shared.mutation("org:revokeInvite", args: ["inviteId": inviteId])
    }

    public static func setAdmin(isAdmin: Bool, memberId: String) async throws {
        try await ConvexService.shared.mutation("org:setAdmin", args: ["isAdmin": isAdmin, "memberId": memberId])
    }

    public static func transferOwnership(newOwnerId: String, orgId: String) async throws {
        try await ConvexService.shared.mutation("org:transferOwnership", args: ["newOwnerId": newOwnerId, "orgId": orgId])
    }

    public static func update(orgId: String, name: String? = nil, slug: String? = nil, avatarId: String? = nil) async throws {
        var data = [String: Any]()
        if let name {
            data["name"] = name
        }
        if let slug {
            data["slug"] = slug
        }
        if let avatarId {
            data["avatarId"] = avatarId
        }
        try await ConvexService.shared.mutate("org:update", args: ["orgId": orgId, "data": data])
    }
}

extension OrgAPI {
    @preconcurrency
    public static func subscribeMyOrgs(
        onUpdate: @escaping @Sendable @MainActor ([OrgWithRole]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: myOrgs, args: [:], type: [OrgWithRole].self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeOrgsWithRole(
            to: myOrgs,
            args: [:],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeMembers(
        orgId: String,
        onUpdate: @escaping @Sendable @MainActor ([OrgMemberEntry]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: members,
            args: ["orgId": orgId],
            type: [OrgMemberEntry].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeOrgMembers(
            to: members,
            args: ["orgId": orgId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribePendingInvites(
        orgId: String,
        onUpdate: @escaping @Sendable @MainActor ([OrgInvite]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: pendingInvites,
            args: ["orgId": orgId],
            type: [OrgInvite].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeInvites(
            to: pendingInvites,
            args: ["orgId": orgId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribePendingJoinRequests(
        orgId: String,
        onUpdate: @escaping @Sendable @MainActor ([JoinRequestEntry]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: pendingJoinRequests,
            args: ["orgId": orgId],
            type: [JoinRequestEntry].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeJoinRequests(
            to: pendingJoinRequests,
            args: ["orgId": orgId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeGet(
        orgId: String,
        onUpdate: @escaping @Sendable @MainActor (Org) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: get, args: ["orgId": orgId], type: Org.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeOrg(
            to: get,
            args: ["orgId": orgId],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeGetBySlug(
        slug: String,
        onUpdate: @escaping @Sendable @MainActor (Org?) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: getBySlug, args: ["slug": slug], type: Org?.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeNullableOrg(
            to: getBySlug,
            args: ["slug": slug],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) },
            onNull: { onUpdate(nil) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeGetPublic(
        slug: String,
        onUpdate: @escaping @Sendable @MainActor (Org?) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(to: getPublic, args: ["slug": slug], type: Org?.self, onUpdate: onUpdate, onError: onError)
        #else
        return ConvexService.shared.subscribeNullableOrg(
            to: getPublic,
            args: ["slug": slug],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) },
            onNull: { onUpdate(nil) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeIsSlugAvailable(
        slug: String,
        onUpdate: @escaping @Sendable @MainActor (SlugAvailability) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: isSlugAvailable,
            args: ["slug": slug],
            type: SlugAvailability.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeSlugAvailability(
            to: isSlugAvailable,
            args: ["slug": slug],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeMembership(
        orgId: String,
        onUpdate: @escaping @Sendable @MainActor (OrgMembership) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: membership,
            args: ["orgId": orgId],
            type: OrgMembership.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeOrgMembership(
            to: membership,
            args: ["orgId": orgId],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeMyJoinRequest(
        orgId: String,
        onUpdate: @escaping @Sendable @MainActor (OrgJoinRequest?) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: myJoinRequest,
            args: ["orgId": orgId],
            type: OrgJoinRequest?.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeNullableOrgJoinRequest(
            to: myJoinRequest,
            args: ["orgId": orgId],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) },
            onNull: { onUpdate(nil) }
        )
        #endif
    }
}

extension TaskAPI {
    public static func create(
        orgId: String,
        assigneeId: String? = nil,
        completed: Bool? = nil,
        priority: TaskItemPriority? = nil,
        projectId: String,
        title: String
    ) async throws {
        var args: [String: Any] = ["orgId": orgId, "projectId": projectId, "title": title]
        if let assigneeId {
            args["assigneeId"] = assigneeId
        }
        if let completed {
            args["completed"] = completed
        }
        if let priority {
            args["priority"] = priority.rawValue
        }
        try await ConvexService.shared.mutate("task:create", args: args)
    }

    public static func update(
        orgId: String,
        id: String,
        assigneeId: String? = nil,
        completed: Bool? = nil,
        priority: TaskItemPriority? = nil,
        projectId: String? = nil,
        title: String? = nil,
        expectedUpdatedAt: Double? = nil
    ) async throws {
        var args: [String: Any] = ["id": id, "orgId": orgId]
        if let assigneeId {
            args["assigneeId"] = assigneeId
        }
        if let completed {
            args["completed"] = completed
        }
        if let priority {
            args["priority"] = priority.rawValue
        }
        if let projectId {
            args["projectId"] = projectId
        }
        if let title {
            args["title"] = title
        }
        if let expectedUpdatedAt {
            args["expectedUpdatedAt"] = expectedUpdatedAt
        }
        try await ConvexService.shared.mutate("task:update", args: args)
    }

    public static func rm(orgId: String, id: String) async throws {
        try await ConvexService.shared.mutate("task:rm", args: ["id": id, "orgId": orgId])
    }

    public static func bulkRm(orgId: String, ids: [String]) async throws {
        try await ConvexService.shared.mutate("task:bulkRm", args: ["ids": ids, "orgId": orgId])
    }

    public static func assign(orgId: String, id: String, assigneeId: String? = nil) async throws {
        var args: [String: Any] = ["orgId": orgId, "id": id]
        if let assigneeId {
            args["assigneeId"] = assigneeId
        }
        try await ConvexService.shared.mutate("task:assign", args: args)
    }

    public static func byProject(orgId: String, projectId: String) async throws -> [TaskItem] {
        #if !SKIP
        try await ConvexService.shared.query("task:byProject", args: ["orgId": orgId, "projectId": projectId])
        #else
        try await Array(ConvexService.shared.queryTaskItems(name: "task:byProject", args: ["orgId": orgId, "projectId": projectId]))
        #endif
    }

    public static func toggle(orgId: String, id: String) async throws {
        try await ConvexService.shared.mutate("task:toggle", args: ["orgId": orgId, "id": id])
    }
}

extension TaskAPI {
    @preconcurrency
    public static func subscribeList(
        orgId: String,
        where filterWhere: TaskWhere?,
        onUpdate: @escaping @Sendable @MainActor (PaginatedResult<TaskItem>) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        let args = listArgs(orgId: orgId, where: filterWhere)
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: list,
            args: args,
            type: PaginatedResult<TaskItem>.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribePaginatedTaskItems(
            to: list,
            args: args,
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeRead(
        orgId: String,
        id: String,
        onUpdate: @escaping @Sendable @MainActor (TaskItem) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: read,
            args: ["id": id, "orgId": orgId],
            type: TaskItem.self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeTaskItem(
            to: read,
            args: ["id": id, "orgId": orgId],
            onUpdate: { r in onUpdate(r) },
            onError: { e in onError(e) }
        )
        #endif
    }

    @preconcurrency
    public static func subscribeByProject(
        orgId: String,
        projectId: String,
        onUpdate: @escaping @Sendable @MainActor ([TaskItem]) -> Void,
        onError: @escaping @Sendable @MainActor (Error) -> Void = { _ in _ = () }
    ) -> String {
        #if !SKIP
        return ConvexService.shared.subscribe(
            to: byProject,
            args: ["orgId": orgId, "projectId": projectId],
            type: [TaskItem].self,
            onUpdate: onUpdate,
            onError: onError
        )
        #else
        return ConvexService.shared.subscribeTaskItems(
            to: byProject,
            args: ["orgId": orgId, "projectId": projectId],
            onUpdate: { r in onUpdate(Array(r)) },
            onError: { e in onError(e) }
        )
        #endif
    }
}
